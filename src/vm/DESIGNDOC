                    +---------------------------+
                    |           CS 124          |
                    | PROJECT 5: VIRTUAL MEMORY |
                    |      DESIGN DOCUMENT      |
                    +---------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Nicholas    Cho         ncho2@caltech.edu
Darius      Simmons     dsimmons@caltech.edu
Austin      Liu         yliu2@caltech.edu

>> Specify how many late tokens you are using on this assignment:

>> What is the Git repository and commit hash for your submission?
   (You only need to include the commit-hash in the file you submit
   on Moodle.)

   Repository URL:
   commit ...

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course instructors.

https://s3.amazonaws.com/piazza-resources/h81s2czg90kwa/hdx5ok0hlxg435/8task3.pdf?AWSAccessKeyId=AKIAIEDNRLJ4AZKBW6HA&Expires=1456444416&Signature=xcUgCawLwIHkrBdNJn9pI3modlE%3D

---- LOGISTICS ----

These questions will help us to keep track of the difficulty level of
assignments, as well as keeping track of which team members worked on
which parts.

>> L1: How many hours did each team member spend on this assignment?
   Make sure that each member's total time is listed.

>> L2: What did each team member focus on for this assignment?  Keep
   descriptions to 25-30 words or less.

Note that this design document is a bit long.  Most of the questions can be
answered pretty briefly.  Don't feel a need to write a long answer if it is
not required by the question.

            PAGE TABLE MANAGEMENT
            =====================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

In page.c:

supplemental page table entry (spte)
struct spte {
    void *upaddr;               /*!< user page address, used as key. */
    struct file *file;
    off_t ofs;
    uint32_t read_bytes;
    uint32_t zero_bytes;
    bool writable;
    struct hash_elem hash_elem; /*!< To put spte in spt. */
    enum page_type type;        /*!< Type of user page */
};

Page type used for identification.
enum page_type {
    PTYPE_STACK,
    PTYPE_MMAP,
    PTYPE_CODE,
    PTYPE_DATA
};


---- ALGORITHMS ----

>> A2: In a few paragraphs, describe your code for locating the frame,
>> if any, that contains the data of a given page.

The data of a program is loaded lazily, i.e. load_segment in process.c
simply records the necessary information to load a segment without
loading it into physical memory yet. When the program needs to access
the page, it triggers a page fault which is handled in exception.c, if
there is a corresponding supplemental page table entry, the corresponding
frame is located using the previously stored information.

>> A3: How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that alias a single frame, or
>> alternatively how do you avoid the issue?

---- SYNCHRONIZATION ----

>> A4: When two user processes both need a new frame at the same time,
>> how are races avoided?

---- RATIONALE ----

>> A5: Why did you choose the data structure(s) that you did for
>> representing virtual-to-physical mappings?

The supplemental page table is implemented with the provided hash table
implementation. It maps user addresses to entries in the SPT. Since
search, insert and delete are of constant time complexity, this allows
page faults to be handled quickly in the kernel.


               PAGING TO AND FROM DISK
               =======================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> B2: When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.

>> B3: When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect the frame Q no longer has?

>> B4: Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.

---- SYNCHRONIZATION ----

>> B5: Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to the
>> textbook for an explanation of the necessary conditions for
>> deadlock.)

>> B6: A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?

>> B7: Suppose a page fault in process P causes a page to be read from
>> the file system or swap.  How do you ensure that a second process Q
>> cannot interfere by e.g. attempting to evict the frame while it is
>> still being read in?

>> B8: Explain how you handle access to paged-out pages that occur
>> during system calls.  Do you use page faults to bring in pages (as
>> in user programs), or do you have a mechanism for "locking" frames
>> into physical memory, or do you use some other design?  How do you
>> gracefully handle attempted accesses to invalid virtual addresses?

---- RATIONALE ----

>> B9: A single lock for the whole VM system would make synchronization
>> easy, but limit parallelism.  On the other hand, using many locks
>> complicates synchronization and raises the possibility for deadlock
>> but allows for high parallelism.  Explain where your design falls
>> along this continuum and why you chose to design it this way.

Currently, a single lock is used for the entire filesystem.

             MEMORY MAPPED FILES
             ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

Additional struct used by threads to keep track of the
files that they have memory mapped.
struct mmap_fileinfo {
    struct list_elem elem;
    mapid_t mapid;
    void *addr;
    int num_pgs;
    struct file *file;
};


---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

Memory mapped files provide a mapping between the virtual address of files
used by a program and some file or file-like resource, allowing the
program to treat the mapped file as if it were part of physical memory.


>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

First when pointers are verified initially we make sure the whole
area is actually mapped to memory. This means that when we get into
sys_mmap we are guarenteed that all of the memory has been allocated.
Next a function called can_write is called. It takes the address and the
size to check. It makes sure that every page in the area is writable so that
we do not overwrite any segments.

---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.

               SURVEY QUESTIONS
               ================

Answering these questions is optional, but it will help us improve the
course in future years.  Feel free to tell us anything you want - these
questions are just to spur your thoughts.  Also, feel free to be completely
honest if there are issues with the assignment or the course - you won't be
penalized.  We can't fix things until we know about them.  :-)

>> In your opinion, was this assignment, or any of the parts of it, too
>> easy or too hard?  Did it take too long or too little time?

It was incredibly difficult to debug a lot of things. Additionally, GDB pauses
on every page fault, so it made it pretty much worthless. If there is a
workaround, it would have been nice to know.

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Were there any parts of the assignment that you felt were unnecessarily
>> tedious or pointless?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the instructor and/or TAs to more
>> effectively assist students, either for future quarters or the remaining
>> projects?

>> Any other comments?

