                    +---------------------------+
                    |           CS 124          |
                    | PROJECT 5: VIRTUAL MEMORY |
                    |      DESIGN DOCUMENT      |
                    +---------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Nicholas    Cho         ncho2@caltech.edu
Darius      Simmons     dsimmons@caltech.edu
Austin      Liu         yliu2@caltech.edu

>> Specify how many late tokens you are using on this assignment:

    6

>> What is the Git repository and commit hash for your submission?
   (You only need to include the commit-hash in the file you submit
   on Moodle.)

   Repository URL: login.cms.caltech.edu:/cs/courses/cs124/teams/Donbots
   commit f466783

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

    Please use bochs.
    
    `make check SIMULATOR=--bochs`

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course instructors.

https://s3.amazonaws.com/piazza-resources/h81s2czg90kwa/hdx5ok0hlxg435/8task3.pdf?AWSAccessKeyId=AKIAIEDNRLJ4AZKBW6HA&Expires=1456444416&Signature=xcUgCawLwIHkrBdNJn9pI3modlE%3D

---- LOGISTICS ----

These questions will help us to keep track of the difficulty level of
assignments, as well as keeping track of which team members worked on
which parts.

>> L1: How many hours did each team member spend on this assignment?
   Make sure that each member's total time is listed.

   Austin Liu: 20
   Darius Simmons: 50
   Nicholas Cho: 50

>> L2: What did each team member focus on for this assignment?  Keep
   descriptions to 25-30 words or less.

    Austin Liu: Making the supplemental page table and switching code in
        process.c and mmap and munmap.
    Darius Simmons: Bringing together supplemental page table and frame table
        code, stack growth, mmap, debugging
    Nicholas Cho: Making the frame table, swapping, and debugging

Note that this design document is a bit long.  Most of the questions can be
answered pretty briefly.  Don't feel a need to write a long answer if it is
not required by the question.

            PAGE TABLE MANAGEMENT
            =====================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

In page.c:

supplemental page table entry (spte)
struct spte {
    void *uaddr;                /*!< User page address, used as key. */
    void *kaddr;                /*!< Kernel address of the page */

    /* These are used by load_segment to load code segments */
    struct file *file;
    off_t ofs;
    uint32_t read_bytes;
    uint32_t zero_bytes;

    bool writable;              /*!< Whether or not the page is writable */
    struct hash_elem hash_elem; /*!< To put spte in spt. */

    enum page_type type;    /*!< Type of user page */
    int swap_index;         /*!< Index of the swapped data, if any */

    bool loaded;
};

Page type used for identification.
enum page_type {
    PTYPE_STACK,
    PTYPE_MMAP,
    PTYPE_CODE,
    PTYPE_DATA
};


---- ALGORITHMS ----

>> A2: In a few paragraphs, describe your code for locating the frame,
>> if any, that contains the data of a given page.

The data of a program is loaded lazily, i.e. load_segment in process.c
simply records the necessary information to load a segment without
loading it into physical memory yet. When the program needs to access
the page, it triggers a page fault which is handled in exception.c, if
there is a corresponding supplemental page table entry, the corresponding
frame is located using the previously stored information.

>> A3: How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that alias a single frame, or
>> alternatively how do you avoid the issue?

We simply check the bits using both the user address and kernel address. We
have the kernel address because the supplemental page table entry for the page
stores both. In the case of the eviction policy, we don't actually do this, and
we use only the user address, which makes our eviction policy slightly less
than optimal, but it still approximates the optimal policy as we keep most of
our accesses to user pages using the user address.


---- SYNCHRONIZATION ----

>> A4: When two user processes both need a new frame at the same time,
>> how are races avoided?

We have a lock for the frame code. Processes ask for a frame through
frame_get_page, and this has a global lock such that only one process
can give out frames at a time.

---- RATIONALE ----

>> A5: Why did you choose the data structure(s) that you did for
>> representing virtual-to-physical mappings?

The supplemental page table is implemented with the provided hash table
implementation. It maps user addresses to entries in the SPT. Since
search, insert and delete are of constant time complexity, this allows
page faults to be handled quickly in the kernel.


               PAGING TO AND FROM DISK
               =======================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

/* Bottom address that the stack can have. */
#define STACK_FLOOR (PHYS_BASE - (PGSIZE * 2048))

/*! Struct representing the swap disk */
struct swapdisk {
    struct block *file;     /*!< Block/file for writing pages to */
    unsigned int size;      /*!< Size of the swap block */
    struct bitmap *slots;   /*!< Bitmap of occupancy. 0 = free, 1 = occupied.
                                 The use of a bitmap requires that the number
                                 of block sectors per page is a whole number,
                                 which it does happen to be. */
};

/* A struct to hold frames. */
struct frame {
    void *kaddr;    /*!< Kernal address to the page that occupies the frame */
    void *uaddr;    /*!< User virtual addres for the page */
    bool pinned;    /*!< Whether the frame is pinned so it can't be swapped */

    struct thread *owner; /*!< The thread that owns the contents of the frame */

    bool dirty; /*!< This bit is set so we know if the frame contents have been
                     dirtied since its creation. We need this information since
                     we reset the actual dirty bit in our eviction policy */

    struct list_elem lelem; /*!< Element used to put frame in frame queue. */
};

/* A lock used so that the supplemental page table knows that a page has
   been evited in the page fault handler. */
static struct lock evictlock;

/* A lock used to prevent two threads from trying to acquire a new frame at the
   same time. */
static struct lock framelock;

/* A list used for the frame table. */
static struct list framequeue;

---- ALGORITHMS ----

>> B2: When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.

We implemented a second chance policy for frame eviction using both the accessed
and dirty bits. We pop the front of the frame queue. If the page has been
dirtied, we reset its dirty bit (saving the fact that the page was at one point
dirty in the frame struct) and then re-add it to the queue. If the page has been
accessed, but not dirtied, we reset its accessed bit and add it back to the
queue. If a page has had neither done, we choose it for eviction and we are
done.

Using this method, we actually give a "third" chance to pages that were dirty
since it is more expensive (we have to write to swap) to deal with dirty pages
compared to ones that were just accessed (we can usually just free it and it can
be loaded back later).

>> B3: When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect the frame Q no longer has?

We end up just freeing and deallocating the page entirely from Q and its page
table before allocaitng a new frame for P. Therefore, there is no conflict
between the page table entries and we ensure that things are deleted and reset
properly.

>> B4: Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.

First you need to check if it is because of a push or a pusha. This is the
only case where the fault address can be below the stack pointer. If this
is the case then it will either be 4 or 32 bytes away from the stack pointer.
Next you make sure that it is close enough to above the stack pointer.
We set it to be a PGSIZE away from the stackpointer. The last consideration was
that it has to be above the stack floor. we had a set size for the stack.
We set it such that you could have 2048 pages in the stack.

---- SYNCHRONIZATION ----

>> B5: Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to the
>> textbook for an explanation of the necessary conditions for
>> deadlock.)

We only have two locks and the code paths that lead to either of those locks
being acquired don't intersect, so that we cannot end up with two threads trying
to acquire locks from each other before one of them releases one of the locks.

>> B6: A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?

We have a lock called evictlock for this purpose. When process P
is evicting a frame from Q, it will acquire evictlock. Pagefault
needs to acquire evictlock in order to bring a page back in. We make
sure that it will pagefault instead of accessing it by clearning
the page from the pagedir.

>> B7: Suppose a page fault in process P causes a page to be read from
>> the file system or swap.  How do you ensure that a second process Q
>> cannot interfere by e.g. attempting to evict the frame while it is
>> still being read in?

The frame is pinned by default when it is created and only unpinned after the
data is loaded into the frame. In the eviction code, we don't consider pinned
frames, so we can't evict that page until it is loaded.

>> B8: Explain how you handle access to paged-out pages that occur
>> during system calls.  Do you use page faults to bring in pages (as
>> in user programs), or do you have a mechanism for "locking" frames
>> into physical memory, or do you use some other design?  How do you
>> gracefully handle attempted accesses to invalid virtual addresses?

We first bring all the pages into memory then pin them so they cannot be
evicted. The system calls are then free to handle the data without page
faulting. Then, when we are done with the pages, we unpin them again so they are
up for eviction.

---- RATIONALE ----

>> B9: A single lock for the whole VM system would make synchronization
>> easy, but limit parallelism.  On the other hand, using many locks
>> complicates synchronization and raises the possibility for deadlock
>> but allows for high parallelism.  Explain where your design falls
>> along this continuum and why you chose to design it this way.

We are using two locks for virtual memory, not including the previous
lock we had for the filesystem. This means that we are on the side of
a lot of synchronization but little parallelism.

             MEMORY MAPPED FILES
             ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

Additional struct used by threads to keep track of the
files that they have memory mapped.
struct mmap_fileinfo {
    struct list_elem elem;
    mapid_t mapid;
    void *addr;
    int num_pgs;
    struct file *file;
};

/* Validates an argument, can be a numeric or a pointer. */
static void *validate_arg(void *addr, enum conversion_type ct, int size,
                          struct intr_frame *f);

---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

Memory mapped files provide a mapping between the virtual address of files
used by a program and some file or file-like resource, allowing the
program to treat the mapped file as if it were part of physical memory.
The eviction policy is different because of where you look for for the data.
Swap files are written to and written back from the swap while other pages
could never need to be written back if they are read only or they have a
file that they are written back to.


>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

First when pointers are verified initially we make sure the whole
area is actually mapped to memory. This means that when we get into
sys_mmap we are guarenteed that all of the memory has been allocated.
Next a function called can_write is called. It takes the address and the
size to check. It makes sure that every page in the area is writable so that
we do not overwrite any segments.

---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.

We used most of the same code. The only differences is, as stated, where you
write to. So we used a switch statement and had an enum for the page type.
We switch based off this enough and either swap or write back to the
file.

               SURVEY QUESTIONS
               ================

Answering these questions is optional, but it will help us improve the
course in future years.  Feel free to tell us anything you want - these
questions are just to spur your thoughts.  Also, feel free to be completely
honest if there are issues with the assignment or the course - you won't be
penalized.  We can't fix things until we know about them.  :-)

>> In your opinion, was this assignment, or any of the parts of it, too
>> easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Were there any parts of the assignment that you felt were unnecessarily
>> tedious or pointless?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the instructor and/or TAs to more
>> effectively assist students, either for future quarters or the remaining
>> projects?

>> Any other comments?

